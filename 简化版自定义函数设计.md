# 简化版自定义函数设计

## 设计核心思路

### 问题分析
1. **主要目标**: 将 `add(x, y) = x + y` 转换为 `(x, y) => x + y`
2. **关键难点**: 处理调用内置函数的情况，如 `rand() = random() + 1`

### 解决方案

#### 1. 表达式到Lambda函数的转换

**核心思路**: 通过字符串替换 + 动态求值

```javascript
// 原表达式: x + y
// 参数: ['x', 'y']
// 参数值: [3, 4]

// 步骤1: 字符串替换
let expr = 'x + y';
expr = expr.replace(/\bx\b/g, '(3)');  // 结果: '(3) + y'
expr = expr.replace(/\by\b/g, '(4)');  // 结果: '(3) + (4)'

// 步骤2: 使用calculator计算
const result = calculator.calculate('(3) + (4)');
```

#### 2. 处理内置函数调用

**优势**: 由于使用calculator.calculate()来计算表达式，内置函数调用自然被支持

```javascript
// 示例: rand() = random() + 1
// 无参数函数，直接计算表达式 'random() + 1'
const result = calculator.calculate('random() + 1');
```

#### 3. 集成到FUNCTIONS对象

**策略**: 直接修改FUNCTIONS对象，添加自定义函数

```javascript
FUNCTIONS[funcName] = {
    func: lambdaFunction,
    args: paramCount,
    argTypes: 'any',
    description: `自定义函数: ${funcName}(${params.join(', ')}) = ${expression}`,
    isCustom: true
};
```

## 实现细节

### 核心函数结构

```javascript
function createLambdaFunction(params, expression, calculator) {
    return function(...args) {
        // 1. 参数数量检查
        if (args.length !== params.length) {
            throw new Error(`参数数量不匹配`);
        }
        
        // 2. 字符串替换
        let evaluationExpr = expression;
        for (let i = 0; i < params.length; i++) {
            const paramName = params[i];
            const argValue = args[i];
            const paramRegex = new RegExp(`\\b${paramName}\\b`, 'g');
            evaluationExpr = evaluationExpr.replace(paramRegex, `(${argValue})`);
        }
        
        // 3. 动态计算
        const result = calculator.calculate(evaluationExpr);
        return result.value;
    };
}
```

### 正则表达式说明

- `\\b${paramName}\\b`: 单词边界匹配，确保只替换完整的标识符
- `g` 标志: 全局替换，替换所有出现的参数名

### 括号包装的原因

```javascript
// 防止运算符优先级问题
// 如果参数值是 '1+2'，替换后变成 'x*(1+2)*y' 而不是 'x*1+2*y'
evaluationExpr = evaluationExpr.replace(paramRegex, `(${argValue})`);
```

## 测试用例

### 1. 基本功能测试

```javascript
// 定义函数
Calculator.calculate('add(x, y) = x + y');

// 调用函数  
Calculator.calculate('add(3, 4)');  // 结果: 7
```

### 2. 内置函数调用测试

```javascript
// 定义调用内置函数的自定义函数
Calculator.calculate('rand() = random() + 1');
Calculator.calculate('sincos(x) = sin(x) + cos(x)');

// 调用
Calculator.calculate('rand()');        // 结果: 随机数+1
Calculator.calculate('sincos(π/4)');   // 结果: sin(π/4) + cos(π/4)
```

### 3. 复杂表达式测试

```javascript
// 定义复杂函数
Calculator.calculate('distance(x1, y1, x2, y2) = sqrt((x2-x1)**2 + (y2-y1)**2)');

// 调用
Calculator.calculate('distance(0, 0, 3, 4)');  // 结果: 5
```

## 优势分析

### 1. 简洁性
- 核心逻辑只有字符串替换 + 动态求值
- 不需要复杂的AST操作
- 代码量少，易于理解和维护

### 2. 兼容性
- 自动支持所有内置函数、运算符、常量
- 不需要特殊处理内置函数调用
- 与现有calculator完全兼容

### 3. 灵活性
- 支持任意复杂的表达式
- 支持嵌套函数调用
- 支持常量使用

## 潜在问题与解决方案

### 1. 参数名冲突问题

**问题**: 如果参数名与内置函数名相同会怎样？
```javascript
// 例如: func(sin) = sin + 1
// 替换后: (0.5) + 1  // 如果传入sin=0.5
```

**解决**: 在函数定义时检查参数名是否与内置函数冲突

### 2. 字符串替换精度问题

**问题**: 正则表达式可能误替换
```javascript
// 例如: func(x) = matrix_x + x
// 如果参数x=5，替换后: matri(5)_x + (5)  // 错误
```

**解决**: 使用单词边界`\b`确保只替换完整标识符

### 3. 性能问题

**问题**: 每次调用都进行字符串替换和重新解析
**影响**: 相对较小，因为表达式通常不会很长

### 4. 递归调用问题

**问题**: 自定义函数调用自己会导致无限递归
**解决**: 在字符串替换时不会替换函数名本身，所以自然避免了递归

## 总结

这个简化设计的核心优势是：
1. **实现简单**: 只需字符串替换 + 现有计算器
2. **功能完整**: 自动支持所有内置功能
3. **易于扩展**: 添加新功能只需修改FUNCTIONS对象
4. **维护性好**: 逻辑清晰，代码量少

通过这种方式，我们用最小的代码量实现了完整的自定义函数功能，同时完美解决了调用内置函数的难点。
